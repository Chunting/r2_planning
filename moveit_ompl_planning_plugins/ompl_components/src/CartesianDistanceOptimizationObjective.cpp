#include "moveit_ompl_components/CartesianDistanceOptimizationObjective.h"

namespace ob = ompl::base;

ompl_interface::CartesianDistanceOptimizationObjective::CartesianDistanceOptimizationObjective(const OMPLPlanningContext* context) : OptimizationObjective(context->getOMPLSpaceInformation())
{
    description_ = "Cartesian distance";
    context_ = context;
    work_state_1_.reset(new robot_state::RobotState(context_->getOMPLStateSpace()->getRobotModel()));
    work_state_2_.reset(new robot_state::RobotState(context_->getOMPLStateSpace()->getRobotModel()));

    xstate_ = context_->getOMPLStateSpace()->allocState();

    // Precompute the names of the links we will compute distance for
    userSpecifiedLinks_ = false;
    const robot_model::JointModelGroup* group = context_->getCompleteInitialRobotState().getJointModelGroup(context_->getGroupName());
    const std::vector<const robot_model::JointModel*>& joints = group->getJointModels();
    for (size_t i = 0; i < joints.size(); ++i)
        link_names_.push_back(joints[i]->getChildLinkModel()->getName());

    minDistance_ = 0.25;
}

ompl_interface::CartesianDistanceOptimizationObjective::~CartesianDistanceOptimizationObjective()
{
    context_->getOMPLStateSpace()->freeState(xstate_);
}

void ompl_interface::CartesianDistanceOptimizationObjective::addLink(const std::string& link)
{
    if (!userSpecifiedLinks_)  // clear out the autogenerated links
    {
        link_names_.clear();
        userSpecifiedLinks_ = true;
    }

    link_names_.push_back(link);
}

double ompl_interface::CartesianDistanceOptimizationObjective::getMinDistance() const
{
    return minDistance_;
}

void ompl_interface::CartesianDistanceOptimizationObjective::setMinDistance(double dist)
{
    assert(dist > 0);
    minDistance_ = dist;
}

ob::Cost ompl_interface::CartesianDistanceOptimizationObjective::stateCost(const ob::State *s) const
{
    return ompl::base::OptimizationObjective::identityCost();
}

// Compute the physical distance between the joints in the group (e.g., workspace distance)
ob::Cost ompl_interface::CartesianDistanceOptimizationObjective::cartesianJointDistance(const robot_state::RobotState& s1,
                                                                                        const robot_state::RobotState& s2) const
{
    double dist = 0.0;
    for(size_t i = 0; i < link_names_.size(); ++i)
    {
        const Eigen::Affine3d& frame_a = s1.getGlobalLinkTransform(link_names_[i]);
        const Eigen::Affine3d& frame_b = s2.getGlobalLinkTransform(link_names_[i]);
        dist += (frame_b.translation() - frame_a.translation()).norm();
    }
    return ob::Cost(dist);

    // const robot_model::JointModelGroup* group = s1.getJointModelGroup(group_name);
    // double dist = 0.0;

    // const std::vector<const robot_model::JointModel*>& joints = group->getJointModels();
    // for (size_t i = 0; i < joints.size(); ++i)
    // {
    //     const Eigen::Affine3d& frame_a = s1.getGlobalLinkTransform(joints[i]->getChildLinkModel());
    //     const Eigen::Affine3d& frame_b = s2.getGlobalLinkTransform(joints[i]->getChildLinkModel());
    //     dist += (frame_b.translation() - frame_a.translation()).norm();
    // }
    // return ob::Cost(dist);
}

ob::Cost ompl_interface::CartesianDistanceOptimizationObjective::motionCost(const ob::State *s1, const ob::State *s2) const
{
    // Lock this function for thread safety of scratch members
    boost::mutex::scoped_lock(work_state_lock_);

    // context_->getOMPLStateSpace()->copyToRobotState(*(work_state_1_.get()), s1);
    // context_->getOMPLStateSpace()->copyToRobotState(*(work_state_2_.get()), s2);
    // return cartesianJointDistance(*(work_state_1_.get()), *(work_state_2_.get()));

    double dist = context_->getOMPLStateSpace()->distance(s1, s2);
    int segments = std::ceil(dist / minDistance_);  // how many segments along this motion?; the max distance is minDistance_

    ob::Cost cost = ob::Cost(0.0);
    context_->getOMPLStateSpace()->copyToRobotState(*(work_state_1_.get()), s1);
    for (int i = 0; i < segments; ++i)
    {
        double t = (double)(i+1) / segments;
        context_->getOMPLStateSpace()->interpolate(s1, s2, t, xstate_);  // must use OMPL interpolate, NOT robot_state::interpolate
        context_->getOMPLStateSpace()->copyToRobotState(*(work_state_2_.get()), xstate_);

        cost = combineCosts(cost, cartesianJointDistance(*(work_state_1_.get()), *(work_state_2_.get())));
        work_state_1_.swap(work_state_2_); // work_state_1 always contains the 'previous' state
    }

    return cost;
}

ob::Cost ompl_interface::CartesianDistanceOptimizationObjective::motionCostHeuristic(const ob::State *s1, const ob::State *s2) const
{
    return motionCost(s1, s2);
}